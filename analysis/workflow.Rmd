---
title: "workflow"
author: "scottzijiezhang"
date: "2018-12-01"
output:
  rmarkdown::html_document:
    highlight: pygments
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy=FALSE, cache=FALSE,
                      dev="png",
                      message=FALSE, error=FALSE, warning=TRUE)
```	


## 1.Quick start

Here we show the most basic steps for a differential methylation analysis followed by peak calling. There is one major step upstream of current analysis that generates mapped reads in BAM files for each sample, which can be done by varies choices of softwares such as [Hisat2](https://ccb.jhu.edu/software/hisat2/index.shtml), 
[tophat2](http://www.ccb.jhu.edu/software/tophat/index.shtml) or [Kallisto](https://pachterlab.github.io/kallisto/). 
we will discuss in the sections below assuming **BAM** file has been obtained. 

This code chunk assumes that you have bam files for sample1-6 `s1.input.bam... s6..input.bam`
and `s1.m6A.bam... s6..m6A.bam`.  

```{r quickStart, eval=FALSE}
library(MeRIPtools)
diffPeaks <- lazyDiffPeaks(  samplenames = c("s1","s2","s3","s4","s5","s6"),
                             gtf = "/path/to/file.gtf",
                             bamFolder = "/path/to/bam_files",
                             modification = "m6A",
                             strandToKeep = "opposite",
                             variables = data.frame(treat = c("Ctl","Ctl","Ctl","Treated","Treated","Treated") ),
                             peakCallMethod = "Binomial",
                             differentialTest = "QNB"
                             )



```


## 2.Standard workflow

### a). Mapped BAM file. 
To analyze for MeRIP-seq data, **MeRIPtools** expect a pair of BAM file for each sample. For each pair of BAM file, the naming convention for **MeRIPtools** is `sample.input.bam` for **INPUT** and `sample.m6A.bam` for m6A **IP** or `sample.m1A.bam` for m1A **IP** sample. They key is **INPUT** and **IP** sample have the same prefix. The mid-name for **IP** sample can be specified in the `countReads` function and thus can be anything.  

### b). GTF annotation file.
For the organism being analyzed, user need to provide an annotation file in gtf format to define the genomic coordinate of gene features. A good source to download those supporting files are [iGenome](https://support.illumina.com/sequencing/sequencing_software/igenome.html). Alternatively, the [GENECODE](https://www.gencodegenes.org/) is also a good source for annotation if you are interested in human and mouse genome.  

### c). The MeRIP class 
The MeRIPtools uses a S4 class system to manage the data involved in the analysis, please see [Manual]() page for more details. The `countReads()` function takes BAM files and gtf annotation as inputs and initializes a MeRIP class object by counting the reads in consecutive bins of size set by the user.

First, let's prepare input data.
```{r prepare, message=FALSE}
library(MeRIPtools)
samplenames <- c("4582WT","4584WT","4587WT","4612WT","4583KO","4586KO","4615KO","4616KO")
bam_dir <- "~/METTL14_liver2017/bam_files"
```

The variable `samplenames` correspond to the prefix of file names in the `bam_dir`.  We can check the files in the `bam_dir`:  
```{r}
list.files(bam_dir)
```
It is okay if your folder don't have `xxx.bai` files. These are BAM file index, which can be generated by the MeRIPtools.  

The next step is to count reads in consecutive bins. Usually we do 50 bp bins for typical library of 20-30 Million reads. If you have deeper coverage, a smaller bin size could increase resolution of the analysis. However, for libraries of shallow coverage, larger bin size is recommended because the smaller the bin size, the less reads are sampled in a bin and therefore the larger sampling error is encountered.  
```{r, eval=FALSE}
MeRIP <- countReads(samplenames = samplenames,
                    gtf = "~/Database/genome/GRCm38.p6/gencode.vM18.annotation.gtf",
                    bamFolder = bam_dir,
                    outputDir = NA,
                    modification = "m6A",
                    strandToKeep = "opposite",
                    fragmentLength = 150,
                    binSize = 50,
                    threads = 20,
                    saveOutput = FALSE
                    )
```
```{r, echo=FALSE}
load("~/Tools/MeRIPtoolsManual/data/MouseLiver_MeRIP.RData")
```
**Note 1** The parameter `strandToKeep` defines the strand of read to count with respect to the transcript strand. Usually, Illumina Truseq library kit or other similar protocol resulted in sequencing opposite strand of the RNA molecules in read1; therefore, default is "opposite" for this parameter. However, for small RNA library protocol, the sense strand of the RNA molecule is sequenced as read1; thus "same" should be set to this parameter.  
**Note 2** The parameter `fragmentLength` defines the average length of the RNAs (insert size of the library). This parameter will affect the location of the reads to be counted. This parameter can be learned from data for paired-end sequencing data.  

A summary of the MeRIP object can be printed by just call the variable name ("MeRIP" in this example). Or use the `summary(MeRIP)` function.
```{r}
MeRIP
```

### d). Perform peak calling for each sample.
After obtaining read count in consecutive bins, we can perform peak calling on each bin of each sample. This step will result in a matrix of logic value to indicate whether each bin is called a peak or not. The result will be stored in a MeRIP.Peak object and returned.  
Currently, two methods were implemented in MeRIPtools to call peak.  
  
**(1) Binomial test** This method models the total read count (Input + IP) and expected ratio of read count in IP as binomial distribution and test the probability of observing the total read count and IP read count where expected ratio $p$ is given by the library size (total coverage) of IP/(Input+IP).   
```{r, eval=FALSE}
MeRIP <- callPeakBinomial(MeRIP = MeRIP, min_counts = 15, peak_cutoff_fdr = 0.05, peak_cutoff_oddRatio = 1, threads = 20)
```
The parameter `min_counts` set the minimal number of total reads (Input + IP) presented in a bin to call this bin peak. The parameter `peak_cutoff_fdr` set the FDR threshold (correct for multiple tests for bins in each gene) to call a bin peak. The parameter `peak_cutoff_oddRatio` set the IP/Input ratio threshold to call a bin peak.  
  
**(2) Fisher's exact test** This method test a contingency table of read count in IP and gene-wise median read count in IP as well as read count in Input and gene-wise median read count in Input.  Basically, it test for the deviation of read count distribution in IP compare to expectation given by the Input sample. This method assumes that only a small segment of a gene is enriched by the IP experiment as gene-wise median was used as a control. When the whole is enriched (e.g. very short transcript or widely methylated genes), this test would fail to detect enrichment.  
```{r, eval=FALSE}
MeRIP <- callPeakFisher(MeRIP = MeRIP, min_counts = 15, peak_cutoff_fdr = 0.05, peak_cutoff_oddRatio = 1, threads = 20)
```
The parameters are the same as previous method except for the oddRatio, which is represented by the (IP/gene-median-IP)/(Input/gene-median-Input).   


### e). Define joint peak for quantitative analysis.
 Although peak calling has been perform for each samples and there are variations of peaks called across samples. However, it is **not** a good idea to directly compare across samples (groups) using the peak calling result (qualitative info) to infer changes of methylation status between groups/conditions (e.g. define emerged/lost peaks). There are two major drawbacks of such analysis: (1) some peak calling result variation actually reflect boundary cases where peak is called in one group with FDR = 0.049 while peak will **not** be called in another group with FDR = 0.051. However, the methylation level are not really different in these two group as the emerged/lost peak seemingly suggested. (2) peak could be call in one group but not another due to differential gene expression. Low expression of a gene in one group could resulted in total read counts lower than the minimal required read count for peak calling and thus not called as a peak. However the IP/Input ratio of this groupd could be roughly the same as another group.  
 Thus, we recommand using quantitative analysis to search for differential methylated regions (peaks). On one hand, we are interested in peaks that are vary across samples, thus we want to make differential test on the union of peaks. On another hand, we don't want to include peaks that are called only one but not any other samples because these peaks are likely false signals. Thus, we defined a joint peak that requires peak to be called in at least 2 (or any other threshold the user defines) samples for comparative analysis. The joint peaks is an representation of the union of peaks in samples analyzed.  
  
```{r, eval=FALSE}
MeRIP <- reportJointPeak(MeRIPdata = MeRIP, joint_threshold = 2, threads = 10)
```
  
Now we have joint peaks stored in the MeRIP.Peak object returned from `reportJointPeak()` function. We can get the joint Peak by `jointPeaks(MeRIP)`.  
```{r}
head( jointPeak(MeRIP) )
```
  
### f). Extract read count of joint Peaks
After obtaining the joint peaks, we will need to summarize the read count in peaks for Input and IP. 
```{r, eval=FALSE}
MeRIP <- jointPeakCount(MeRIP)
```
This step is to prepare read count data for differential methylation test. If you are interested in peak read count data, you can extract it by:
```{r}
Input_count <- extractInput(MeRIP)
IP_count <- extractIP(MeRIP)

dim(Input_count)
```

### g). Inferential test
Usually, we are interested in compare samples across experiment conditions or genotypes. We implemented three alternative tests in MeRIPtools: `RADARtest` using a random effect model, `QNBtest` using quad-negative binomial model and `BetaBinTest` using beta-binomial regression model.
Before we run the test, we need to set the variable associated with each samples. Predictor variable and potential covariates are inputed as a data.frame.
```{r, eval= FALSE}
variable(MeRIP) <- data.frame( genotype = c("WT","WT","WT","WT","KO","KO","KO","KO") )

## if there is covariates
variable(MeRIP) <- data.frame( genotype = c("WT","WT","WT","WT","KO","KO","KO","KO"), covariate1 = c(...),  covariate2 = c(...), ... )
```
#### **(1) QNB**
QNB test was introduced by [Liu et al 2017 *BMC Bioinformatics*](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-017-1808-4). Here we implemented a wrapper function to call QNB test. **Note** this test is designed for small sample size scenario and cannot incorporate covariates. Thus I recommond using this test for cell line experiment where only 2-3 technical/biological replicates are available.  
```{r, eval=FALSE}
MeRIP <- QNBtest(MeRIP)
```
  
#### **(2) RADARTest**
To be add...
#### **(3) BetaBinTest**
To be add...

### h). Check result
Finally, we want to check the joint peaks and associated test statistics. The function `results()` will extract the joint peaks and associated differential test statistics.
```{r}
allPeakResult <- results(MeRIP)

head(allPeakResult)
```
The column `beta` is the coefficient associated with the predictor variable. The interpretation is log2-fold change in `QNBtest` (log fold change RADARtest and BetaBinTest). The `p_value` is the P value for the differential test of each peak. `padj` is P value adjusted for multiple testing, which can be interpreted as false discovery rate (FDR).  

To filter for significantly differentially methylated peaks, we usually use a FDR < 10% cutoff to filter the result:
```{r}
diff_peaks <- allPeakResult[allPeakResult$padj < 0.1,]

dim(diff_peaks)
```
There are 688 peaks differentially methylated peaks tested by QNB in this example. You can save the result to a file by:
```{r, eval=FALSE}
write.table(diff_peaks, "Path/to/file/location.xls", sep = "\t", col.names = T, row.names = F, quote = F)
```

## 3. Peak calling only analysis
  
If you are only interested in peak calling and want to obtain peaks consistent across some samples, you can report consistent peak after step **2 d)** in previous section.  

For example, I'm only interested in peaks that are consistent in the first two samples:
```{r, eval=FALSE}
consistentPeak1 <- consistentPeak(MeRIP, samplenames = c("4582WT","4584WT"), joint_threshold = 2)
```

Or I can report peaks that are consistent in at least 3 samples among 4 samples indicated by setting the `joint_threshold=3` :
```{r, eval=FALSE}
consistentPeak2 <- consistentPeak(MeRIP, samplenames = c("4582WT","4584WT","4587WT","4612WT"), joint_threshold = 3 )
```

**Warning** This function is intended to quality check peaks called in subset of samples or to just report a peak file. It is strongly not recommended to use this function to report peaks for two groups and compare the two peak files to infer variation between groups.  





